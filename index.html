<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />

    <style id="webmakerstyle">
      :root {
        --unit: 100px;
      }
      * {
        box-sizing: border-box;
      }
      *:focus {
        outline-offset: 3px;
        outline-color: black;
        outline-width: 5px;
        outline-style: dashed;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        font-size: 200%;
        line-height: 1.4;
        overflow-x: hidden;
        margin: 0;
        min-height: 100vh;
        background: linear-gradient(
          180deg,
          skyblue 0%,
          skyblue 82%,
          white 100%
        );
        text-align: center;
        position: relative;
      }
      .screen {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        opacity: 0;
        visibility: hidden;
      }
      .screen.visible {
        opacity: 1;
        visibility: visible;
      }
      .btn {
        font-family: inherit;
        font-size: inherit;
        padding: 1rem 2rem;
        border: 4px solid black;
        box-shadow: 6px 6px;
        cursor: pointer;
        transition: 0.25s ease;
      }
      .btn:hover,
      .btn:focus {
        transform: rotateZ(5deg);
      }
      .btn:active {
        box-shadow: 1px 1px;
      }
      .container {
        transform: rotateX(60deg) rotateY(0deg) rotateZ(-45deg);
        position: relative;
        left: calc(var(--unit) * 6 * 0.2);
        width: calc(var(--unit) * 6);
        transform-origin: center center;
      }
      .tile {
        font-size: calc(var(--unit) * 0.7);
        text-align: center;
        --border-width: 0.1em;
        width: var(--unit);
        height: var(--unit);
        position: absolute;
        background: #8ba069;
        border-left: var(--border-width) solid rgba(0, 0, 0, 0.5);
        border-bottom: var(--border-width) solid rgba(0, 0, 0, 0.3);
        color: rgb(65, 78, 45);

        transition: 0.25s ease;
      }

      .tile:not(.hole):not(.cover) {
        text-shadow: 7px -4px 0px rgba(0, 0, 0, 0.5),
          6px -4px 0px rgba(0, 0, 0, 0.6), 0px -4px 0px rgba(255, 255, 255, 0.6);
      }
      .game-started .tile:not(.hole):not(.cover):hover,
      .game-started .tile:not(.hole):not(.cover):focus {
        margin-left: 10px;
        margin-top: -10px;
        z-index: 10;
        box-shadow: 5px -5px 20px 2px rgba(0, 0, 0, 0.35);
      }
      .cover {
        background: skyblue;
        border: 0;
      }
      /* blast rays */
      .hole:before {
        content: "";
        display: block;
        position: absolute;
        width: 10px;
        height: 200vw;
        bottom: 200vh;
        background: white;
        left: 20px;
        opacity: 0;
        transition: 0.5s ease;
        transition-delay: var(--blast-delay);
      }
      .bomb-place-anim-1 .hole:before {
        opacity: 1;
        bottom: 30px;
      }
      .bomb-place-anim-2 .hole:before {
        height: 0px;
      }
      .bomb-place-anim-2 .hole {
        background: white;
      }
      .game-started .hole {
        --hole-width: 0.5em;
        background: crimson;
        border-left: 0;
        border-bottom: 0;
        border-right: var(--hole-width) solid rgba(0, 0, 0, 0.5);
        border-top: var(--hole-width) solid rgba(0, 0, 0, 0.3);
      }
      .game-started .hole:after {
        content: "💣";
        display: block;
        margin: -0.2em 0 0 0.1em;
      }
      .tile:focus {
        outline-width: 8px;
        outline-style: solid;
        outline-color: black;
      }
      .overlay {
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0) 50%,
          rgba(0, 0, 0, 0.2) 70%,
          rgba(0, 0, 0, 0.4)
        );
        background-size: 5px 5px;
        pointer-events: none;
        position: fixed;
        z-index: 3;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        opacity: 0.6;
      }
      [data-screen="game"] {
        display: flex;
        justify-content: center;
        transform-style: preserve-3d;
        perspective: 1170px;
      }
      details {
        margin: 2rem;
        padding: 2rem;
        background: white;
        transition: 0.5s cubic-bezier(0.5, -0.03, 0.25, 1);
        border: 5px solid;
        box-shadow: 6px 6px;
      }
      details[open] {
        transform: translateY(-240px);
      }
      /* MESSAGE */
      .message {
        position: fixed;
        top: 30vh;
        left: 50%;
        width: 3px;
        height: 10px;
        transform: translateX(-50%);
        overflow: hidden;
        background: white;
        transition: 0.4s cubic-bezier(0.99, -0.1, 0.71, 1.68);
      }
      .message__text {
        overflow: hidden;
        max-height: 0;
      }
      .message-anim-1 .message {
        width: 90vw;
      }
      .message-anim-2 .message {
        transition: 0.3s ease;
        width: 90vw;
        transform: translateX(-50%) scale(1);

        border: 5px solid black;
        box-shadow: 6px 6px;
      }
      .message-anim-2 .message__text {
        max-height: 300px;
      }
      .message-anim-2 .message {
        padding: 3rem;
        height: auto;
      }
    </style>
  </head>
  <body>
    <div class="screen visible" data-screen="menu">
      <h1>
        Minesweeper "Back"wards
      </h1>

      <div class="d-f">
        <button
          class="btn"
          type="button"
          data-level="0"
          onclick="setupGame(event)"
        >
          Easy
        </button>
        <button
          class="btn"
          type="button"
          data-level="1"
          onclick="setupGame(event)"
        >
          Hard
        </button>
        <!-- <button
          class="btn"
          type="button"
          data-level="2"
          onclick="setupGame(event)"
        >
          Hard
        </button> -->
      </div>

      <div>
        <details>
          <summary>See Help</summary>
          <h2>If you know how to play Minesweeper:</h2>
          <p>
            You need to play Minesweeper backwards. You know the mines and you
            need to put correct number on each tile.
          </p>
          <h2>If you don't know how to play Minesweeper:</h2>
          <p>
            A grid will show up with bombs placed in random cells. Your task is
            to assign correct number to the cells which do not have bomb.
          </p>
          <p>
            A cell's number is the count of bombs that are placed around it i.e.
            the (at most) eight cells surrounding it, like so:
          </p>
        </details>

        <details>
          <summary>Controls</summary>
          <h2>Mouse</h2>
          <p>Click any cell to cycle between values 0 to 8.</p>
          <h2>Keyboard</h2>
          <p>
            Navigate through cells with <kbd>Tab</kbd> or <kbd>Arrow</kbd> keys.
            Press <kbd>Space</kbd> to cycle between values 0 to 8 or simply
            press the numeric key to assign value directly.
          </p>
        </details>
      </div>
    </div>
    <div class="screen" data-screen="help">
      <h2>Help</h2>
      <p>Hahahaha</p>
    </div>
    <div class="screen" data-screen="game">
      <div id="tileContainer" class="container"></div>
      <!-- <div id="messageEl" class="message">Click to start</div> -->
    </div>

    <div class="overlay"></div>

    <script>
      const DEBUG = true;
      let cellSize = parseInt(
        window
          .getComputedStyle(document.documentElement)
          .getPropertyValue("--unit")
      );
      const W = window.innerWidth;
      const H = window.innerHeight;
      let grid = [];
      let input = [];
      let n = 6;
      const levels = {
        0: { n: 3, mines: 2 },
        1: { n: 6, mines: 8 },
        2: { n: 12, mines: 20 }
      };
      const screens = [...document.querySelectorAll(".screen")];
      let hasGameStarted = false;
      let currentScreen = "mainmenu";

      function random(a, b) {
        return a + ~~(Math.random() * (b - a));
      }

      function changeScreen(name) {
        screens.forEach(screen => screen.classList.remove("visible"));
        document
          .querySelector(`[data-screen="${name}"]`)
          .classList.add("visible");
        currentScreen = name;
      }

      function logField(arr) {
        console.log("Field:");
        for (let y = 0; y < n; y++) {
          console.log(arr[y]);
          console.log("---");
        }
      }

      function makeTile({ isHole, isFake }) {
        // const isHole = hole || Math.random() > 0.7;
        const t = document.createElement(isFake || isHole ? "div" : "button");
        t.classList.add("tile");
        if (isHole) {
          t.classList.add("hole");
          t.tileType = "hole";
        }
        return t;
      }
      function gen(level) {
        n = levels[level].n;
        const numMines = levels[level].mines;
        cellSize = ~~((Math.min(W, H) * 0.8) / n);
        document.documentElement.style.setProperty("--unit", `${cellSize}px`);
        tileContainer.style.left = `${cellSize * n * 0.15}px`;
        tileContainer.style.width = `${cellSize * n}px`;
        let minesPos = [];
        while (minesPos.length < numMines) {
          let cellIndex = random(0, n * n);
          if (!minesPos.includes(cellIndex)) {
            minesPos.push(cellIndex);
          }
        }
        minesPos = minesPos.map(pos => {
          return { y: ~~(pos / n), x: pos % n };
        });

        Array.from(tileContainer.children).map(i => i.remove());
        grid = [];
        for (var i = 0; i < n; i++) {
          grid[i] = [];
          input[i] = [];
          for (var j = 0; j < n; j++) {
            grid[i][j] = 0;
            input[i][j] = 0;
          }
        }
        for (var j = 0; j < n + 1; j++)
          for (var i = 0; i < n; i++) {
            const t = makeTile({
              isHole: minesPos.some(pos => pos.x === i && pos.y === j),
              isFake: j === n
            });
            t.style.top = `${j * cellSize}px`;
            t.style.left = `${i * cellSize}px`;
            t.count = 0;
            t.posX = i;
            t.posY = j;
            if (!t.className.match(/(hole|cover)/)) {
              t.setAttribute("aria-label", `Row ${j + 1}, Column ${i + 1}`);
            }
            const offset = -10;
            t.style.transform = `translate(${offset}px, -${offset}px)`;
            t.style.transitionDelay = `${(j * n + i) * 0.02}s`; //`${Math.random() * 0.5}s`;
            t.style.setProperty("--blast-delay", `${Math.random() * 0.3}s`);
            t.style.transitionTimingFunction =
              "0.25s cubic-bezier(0, 0.6, 0.6, 1.34)";
            t.style.opacity = 0;
            setTimeout(() => {
              t.style.transform = `translate(0px, 0px)`;
              t.style.opacity = 1;
            }, 1);
            setTimeout(() => {
              t.style.transitionTimingFunction = null;
              t.style.transitionDelay = null;
              t.style.transitionDuration = null;
            }, 2000);
            if (j === n) {
              t.setAttribute("class", "tile cover");
            } else {
              if (t.tileType === "hole") {
                grid[i][j] = -1;
                // iterate around the current cell (i,j)
                for (let x = -1; x <= 1; x++)
                  for (let y = -1; y <= 1; y++) {
                    if (
                      (x === 0 && y === 0) ||
                      i + x < 0 ||
                      j + y < 0 ||
                      i + x > n - 1 ||
                      j + y > n - 1 ||
                      grid[i + x][j + y] === -1
                    )
                      continue;
                    grid[i + x][j + y] = grid[i + x][j + y] + 1;
                  }
              }
            }
            tileContainer.append(t);
          }
        // logField(grid);
      }

      function checkWin() {
        for (var i = 0; i < n; i++) {
          for (var j = 0; j < n + 1; j++) {
            if (grid[i][j] === -1) continue;

            if (grid[i][j] !== input[i][j]) {
              return false;
            }
          }
        }
        return true;
      }
      function addClassLater(el, claz, delay) {
        setTimeout();
      }
      function wait(duration) {
        return new Promise(resolve => {
          setTimeout(resolve, duration);
        });
      }

      async function showMessage(msg) {
        const el = document.createElement("div");
        el.setAttribute("role", "alert");
        el.className = "message";
        document.body.append(el);
        el.innerHTML = `<div class="message__text">${msg}</div>`;

        await wait(10);
        document.body.classList.add("message-anim-1");
        await wait(430);
        document.body.classList.add("message-anim-2");
      }
      async function hideMessage() {
        document.body.classList.remove("message-anim-2");
        document.querySelector(".message").remove();
        document.body.classList.remove("message-anim-1");
      }
      function setupGame(e, level) {
        if (e) {
          level = parseInt(e.target.dataset.level, 10);
        }
        gen(level);
        changeScreen("game");
        showMessage("Click to start");
        e.stopPropagation();
      }

      async function startGame() {
        hideMessage();
        document.body.classList.add("bomb-place-anim-1");

        await wait(500);

        document.body.classList.add("bomb-place-anim-2");
        shake(0.5);

        await wait(500);

        document.body.classList.add("bomb-place-anim-3");
        document.body.classList.add("game-started");
        hasGameStarted = true;
        startTime = Date.now();
      }

      function setTileValue(el, value, diff = 1) {
        input[el.posX][el.posY] =
          value !== undefined ? value : input[el.posX][el.posY] + diff;
        input[el.posX][el.posY] %= 9;
        if (input[el.posX][el.posY] < 0) {
          input[el.posX][el.posY] = 8;
        }
        el.textContent = [1, 2, 3, 4, 5, 6, 7, 8][input[el.posX][el.posY] - 1];
        // el.textContent = ["1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣"][
        //   input[el.posX][el.posY] - 1
        // ];

        if (checkWin()) {
          const time = (Date.now() - startTime) / 1000;
          hasGameStarted = false;
          setTimeout(() => {
            showMessage(
              `You completed the level in <strong>${time} seconds!</strong>`
            );
          }, 10);
        }
      }
      function tileClickHandler(e) {
        if (!hasGameStarted) return;
        const el = e.target;
        if (el.className.match(/tile/) && el.tagName === "BUTTON") {
          setTileValue(el, undefined, e.button === 0 ? 1 : -1);
        }
      }
      window.oncontextmenu = e => {
        if (e.target.className.match(/tile/)) {
          tileClickHandler(e);
          return false; // cancel default menu
        }
      };
      window.onclick = e => {
        if (!grid.length) {
          return;
        }
        if (currentScreen === "game" && !hasGameStarted) {
          startGame();
        }

        tileClickHandler(e);
      };

      function navigate(el, dir) {
        function getVerticalEl(el, x, y) {
          return el.parentElement.children[y * n + x];
        }

        if (dir === "right" || dir === "left") {
          let nextEl = el;
          const fnName =
            dir === "right" ? "nextElementSibling" : "previousElementSibling";
          while (
            (nextEl = nextEl[fnName]
              ? nextEl[fnName]
              : el.parentElement.children[dir === "right" ? 0 : n * n - 1])
          ) {
            if (
              !nextEl.classList.contains("hole") &&
              !nextEl.className.match(/cover/)
            ) {
              break;
            }
          }
          nextEl.focus();
        } else if (dir === "up" || dir === "down") {
          let nextEl = el;
          const diff = dir === "down" ? 1 : -1;
          while (
            (nextEl =
              nextEl.posY + diff < n && nextEl.posY + diff >= 0
                ? getVerticalEl(nextEl, nextEl.posX, nextEl.posY + diff)
                : getVerticalEl(
                    nextEl,
                    nextEl.posX,
                    dir === "down" ? 0 : n - 1
                  ))
          ) {
            if (
              !nextEl.classList.contains("hole") &&
              !nextEl.className.match(/cover/)
            ) {
              break;
            }
          }
          nextEl.focus();
        }
      }

      window.onkeyup = e => {
        // console.log(e.key);
        const target = e.target;

        if (!target.className.match(/tile/)) {
          if (
            ["ArrowRight", "ArrowLeft", "ArrowUp", "ArrowDown"].includes(e.key)
          ) {
            tileContainer.querySelector(".tile:not(.cover):not(.hole)").focus();
          }
        }

        let num = parseInt(e.key, 10);
        if (!isNaN(num)) {
          setTileValue(target, num);
        }

        if (e.key === "ArrowRight") {
          navigate(e.target, "right");
        } else if (e.key === "ArrowLeft") {
          navigate(e.target, "left");
        } else if (e.key === "ArrowDown") {
          navigate(e.target, "down");
        } else if (e.key === "ArrowUp") {
          navigate(e.target, "up");
        }

        // to prevent scrolling
        if (
          ["ArrowRight", "ArrowLeft", "ArrowUp", "ArrowDown"].includes(e.key)
        ) {
          e.preventDefault();
        }
      };

      let shakeTime;
      const shakeIntensity = 15;
      function shake(time) {
        function shakeRepeater() {
          shakeTime -= 1 / 60;
          document.body.style.left = `${random(
            -shakeIntensity,
            shakeIntensity
          )}px`;
          document.body.style.top = `${random(
            -shakeIntensity,
            shakeIntensity
          )}px`;
          if (shakeTime > 0) {
            requestAnimationFrame(shakeRepeater);
          } else {
            document.body.style.marginLeft = null;
            document.body.style.marginTop = null;
          }
        }
        shakeTime = time;
        shakeRepeater();
      }

      function tweetScore() {
        window.open(
          `http://twitter.com/share?url=${location.href}&text=🎮 I reached level ${time} of Key Battle 🔥.&count=horiztonal&hashtags=js13k,game,indiedev&via=chinchang457&related=chinchang457`
        );
      }

      // setupGame(null, 1);
      // hideMessage();
    </script>
  </body>
</html>
